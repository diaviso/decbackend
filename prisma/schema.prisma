generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  USER
}

enum QuizDifficulty {
  FACILE
  MOYEN
  DIFFICILE
}

enum QuestionType {
  QCM
  QCU
}

enum TopicStatus {
  OUVERT
  FERME
  RESOLU
}

model User {
  id                  String              @id @default(uuid())
  email               String              @unique
  password            String?
  firstName           String
  lastName            String
  country             String?
  city                String?
  avatar              String?
  role                UserRole            @default(USER)
  isEmailVerified     Boolean             @default(false)
  googleId            String?             @unique
  stars               Int                 @default(0)
  showInLeaderboard   Boolean             @default(true)
  isPremium           Boolean             @default(false)
  premiumExpiresAt    DateTime?
  stripeCustomerId    String?             @unique
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  emailVerifications EmailVerification[]
  passwordResets     PasswordReset[]
  articles          Article[]
  articleLikes      ArticleLike[]
  comments          Comment[]
  commentLikes      CommentLike[]
  forumTopics       ForumTopic[]
  forumComments     ForumComment[]
  forumCommentLikes ForumCommentLike[]
  quizAttempts      QuizAttempt[]
  quizExtraAttempts QuizExtraAttempt[]
  payments          Payment[]

  @@map("users")
}

model EmailVerification {
  id        String   @id @default(uuid())
  userId    String
  code      String
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("email_verifications")
}

model PasswordReset {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("password_resets")
}

model Theme {
  id          String   @id @default(uuid())
  title       String
  description String
  position    Int      @unique
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  quizzes Quiz[]

  @@map("themes")
}

model Quiz {
  id              String         @id @default(uuid())
  themeId         String
  title           String
  description     String
  difficulty      QuizDifficulty
  timeLimit       Int
  passingScore    Int
  requiredStars   Int            @default(0)  // Minimum stars required to unlock this quiz
  isFree          Boolean        @default(false)
  isActive        Boolean        @default(true)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  theme           Theme                  @relation(fields: [themeId], references: [id], onDelete: Cascade)
  questions       Question[]
  attempts        QuizAttempt[]
  extraAttempts   QuizExtraAttempt[]

  @@map("quizzes")
}

model Question {
  id         String         @id @default(uuid())
  quizId     String
  content    String
  type       QuestionType
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt
  
  quiz    Quiz     @relation(fields: [quizId], references: [id], onDelete: Cascade)
  options Option[]

  @@map("questions")
}

model Option {
  id         String   @id @default(uuid())
  questionId String
  content    String
  isCorrect  Boolean  @default(false)
  createdAt  DateTime @default(now())
  
  question Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@map("options")
}

model QuizAttempt {
  id          String   @id @default(uuid())
  userId      String
  quizId      String
  score       Int
  starsEarned Int      @default(0)
  completedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  quiz Quiz @relation(fields: [quizId], references: [id], onDelete: Cascade)

  @@map("quiz_attempts")
}

model QuizExtraAttempt {
  id          String   @id @default(uuid())
  userId      String
  quizId      String
  starsCost   Int      // Number of stars spent for this extra attempt
  purchasedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  quiz Quiz @relation(fields: [quizId], references: [id], onDelete: Cascade)

  @@map("quiz_extra_attempts")
}

model BlogCategory {
  id        String    @id @default(uuid())
  name      String    @unique
  slug      String    @unique
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  
  articles Article[]

  @@map("blog_categories")
}

model Tag {
  id        String   @id @default(uuid())
  name      String   @unique
  slug      String   @unique
  createdAt DateTime @default(now())
  
  articles Article[]

  @@map("tags")
}

model Article {
  id         String   @id @default(uuid())
  authorId   String
  categoryId String
  title      String
  slug       String   @unique
  content    String
  excerpt    String?
  coverImage String?
  published  Boolean  @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  author   User          @relation(fields: [authorId], references: [id], onDelete: Cascade)
  category BlogCategory  @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  tags     Tag[]
  comments Comment[]
  likes    ArticleLike[]

  @@map("articles")
}

model ArticleLike {
  id        String   @id @default(uuid())
  userId    String
  articleId String
  createdAt DateTime @default(now())
  
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  article Article @relation(fields: [articleId], references: [id], onDelete: Cascade)

  @@unique([userId, articleId])
  @@map("article_likes")
}

model Comment {
  id        String   @id @default(uuid())
  articleId String
  userId    String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  article Article       @relation(fields: [articleId], references: [id], onDelete: Cascade)
  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  likes   CommentLike[]

  @@map("comments")
}

model CommentLike {
  id        String   @id @default(uuid())
  userId    String
  commentId String
  createdAt DateTime @default(now())
  
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment Comment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@map("comment_likes")
}

model ForumCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  slug        String   @unique
  description String?
  createdAt   DateTime @default(now())
  
  topics ForumTopic[]

  @@map("forum_categories")
}

model ForumTopic {
  id         String      @id @default(uuid())
  authorId   String
  categoryId String
  title      String
  content    String
  status     TopicStatus @default(OUVERT)
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  
  author   User            @relation(fields: [authorId], references: [id], onDelete: Cascade)
  category ForumCategory   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  comments ForumComment[]

  @@map("forum_topics")
}

model ForumComment {
  id              String   @id @default(uuid())
  topicId         String
  userId          String
  parentCommentId String?
  content         String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  topic         ForumTopic         @relation(fields: [topicId], references: [id], onDelete: Cascade)
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  parentComment ForumComment?      @relation("CommentReplies", fields: [parentCommentId], references: [id], onDelete: Cascade)
  replies       ForumComment[]     @relation("CommentReplies")
  likes         ForumCommentLike[]

  @@map("forum_comments")
}

model ForumCommentLike {
  id        String   @id @default(uuid())
  userId    String
  commentId String
  createdAt DateTime @default(now())

  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  comment ForumComment @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@unique([userId, commentId])
  @@map("forum_comment_likes")
}

// RAG - Document storage
model Document {
  id           String   @id @default(uuid())
  filename     String   // Original filename
  filepath     String   // Path where the file is stored
  title        String?  // Optional custom title
  description  String?  // Optional description
  fileSize     Int      // File size in bytes
  mimeType     String   // MIME type (application/pdf)
  totalPages   Int?     // Number of pages (for PDFs)
  totalChunks  Int      @default(0) // Number of chunks created
  isProcessed  Boolean  @default(false) // Whether the document has been processed
  processedAt  DateTime? // When the document was processed
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  chunks DocumentChunk[]

  @@map("documents")
}

// RAG - Document chunks with embeddings
model DocumentChunk {
  id          String   @id @default(uuid())
  documentId  String
  content     String   // The text content of this chunk
  chunkIndex  Int      // Order of this chunk in the document
  pageNumber  Int?     // Page number this chunk came from (for PDFs)
  metadata    Json?    // Additional metadata (headers, section titles, etc.)
  embedding   Json?    // Vector embedding stored as JSON array (OpenAI uses 1536 dimensions)
  createdAt   DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@index([documentId])
  @@map("document_chunks")
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model Payment {
  id                String        @id @default(uuid())
  userId            String
  amount            Int           // Amount in cents
  currency          String        @default("EUR")
  status            PaymentStatus @default(PENDING)
  stripePaymentId   String?       @unique
  stripeSessionId   String?       @unique
  description       String?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
}
